---
title: "Estudio de alta frecuencia de la riqueza microbiana entre 2 tipos de frentes oceanográficos"
author: "Nicolás, Simón, Nicole, Gonzalo, Martina"
format: html
editor: visual
theme: cerulean
output-dir: "asdasdasdasd"
---

## 

```{r}
#| include: false
library(nlme)
library(geepack)
library(marmap)
library(dplyr)
library(geosphere) # Para pasar lat y long a distancias
library(ggplot2)
library(tidyr)
library(car) 
library(DHARMa)
```

## Contexto

Estudiar comunidad del plancton microbiano en el atlántico Sudoccidental Sur. Especificamente compar la riqueza del frente Estable con el frente Transitorio.

## Analisis Exploratorio Datos

```{r}
datos<-read.csv("../datos/complete_data.csv", header=T)
summary(datos)

####DISTANCIA####
# Coordenadas iniciales por localidad
ref_points <- data.frame(
  source = c("bloom", "talud"),
  ref_lat = c(-48.2656, -45.6659),
  ref_lon = c(-63.7595, -59.7381)
)

# Calcular distancia al punto inicial de cada localidad
datos <- datos %>%
  left_join(ref_points, by = "source") %>%
  mutate(
    dist_m = distHaversine(
      p1 = cbind(ref_lon, ref_lat),
      p2 = cbind(lon, lat)
    ),
    dist = dist_m / 1000
  )

datos = datos[, -c(2,3,12:14 )]
```

Cambiamos los nombres a los frentes

```{r}

datos$source <- recode_factor(datos$source,
                              "bloom" = "transitorio",
                              "talud" = "estable")

```

### Analiticamente

```{r}
resumen_frente <- datos %>%
  group_by(source) %>%
  summarize(
    n = n(),
    riqueza = mean(riqueza),
    salinidad = mean(SSS),
    chl = mean(Chl),
    DE_chl= sd(Chl) , 
    POC = mean(POC),
    gamma = mean(gamma),
    SST = mean(SST),
    bbp = mean(bbp)
  )
knitr :: kable(resumen_frente,
               
               caption = "Medidas resumen por frente ") 

```

### Graficamente

```{r}
spahettiPlot = function (var, nombre){
  
ggplot(data = datos, aes(x = dist,
                         y = {{var}},
                         colour = source,
                         )) +
  labs(title = paste("Spaghetti-plot " , nombre , " en distancia"),
       x = "Distancia (km)",
       y = nombre) +
  geom_point() +
  geom_line() +
  facet_grid(. ~source ) +
  theme_bw()
}
```

#### Clorofila

```{r}

ggplot(datos, aes(x=source, y=Chl)) +
        geom_boxplot(aes(group =source ,  color=source), color="black") +        # outlier.shape = NA
        theme_bw()+
        geom_jitter(alpha=0.3, size=2,aes(color=source), 
                    position = position_jitter(width = .2))+
        theme(legend.position="top", 
              legend.text=element_text(size = 12),
              legend.title = element_text(size=12, face="bold")) +
        ylab("Chl")+xlab("Frente") 
```

```{r}
spahettiPlot(Chl , "Clorofila")
spahettiPlot(riqueza , "riqueza")
spahettiPlot(POC , "POC")
spahettiPlot(gamma , "gamma")
spahettiPlot(SST , "SST")
spahettiPlot(SSS , "SSS")
spahettiPlot(bbp , "bbp")


```

### Linealidad

```{r}
#| warning: false

linealidadPlot = function (var, nombre){
  
ggplot(datos, aes(x={{var}}, y= riqueza,group = source , color = source)) + 
  geom_point(  size=3,  shape=19 ) +  
  geom_smooth(method=lm, se=F, fullrange=F, size=0.5)+ 
  xlab( nombre ) +  ylab("Riqueza") 
}

linealidadPlot(Chl,"Chl")
linealidadPlot(POC,"POC")
linealidadPlot(bbp,"bbp")
linealidadPlot(gamma,"gamma")
linealidadPlot(SST,"SST")
linealidadPlot(SSS,"SSS")


```

### Hipótesis

Debido a las caracterticas de cada comunidad , se espera que la riqueza de especies sea distinta en cada zona.

### Predicción

El frente Estable se espera encontrar menor riqueza de especies ya las condiciones ambientales se mantienen estables en el tiempo. Por el otro lado, el Frente transitorio al variar sus condiciones ambientales se espera una mayor cantidad de riqueza.

Unidad de muestreo: Cada 5 ml de agua de la trayectoria del barco.

Variables **Explcatorias:** (Cuantitativas continuas y distribución aleatoria, nomal)

-   SSS (UPS)

-   SST (°C)

-   Tamaño de particulas

-   bbp (mg/m3)

-   Clorofila (mg/m3)

-   POC (mg/m3)

Variable efectos aleatorios:

-   Distancia : La distancia se puede tomar como una variable de efectos aleatorios, pero como no nos interesa en nuestra hipotesis, se decidió usar un análisis **marginal** con una matriz de correlación donde la correlación disminuye a mayores distancias.

Variable **Respuesta:**

-   Riqueza ( Numero Sps distintas ) / 5 ml de agua . Cota inferior ( 0 , + ∞) \~ Distribución Poisson

Replicas: 25 Para frente estable, 50 para transitorio

### Conclución

Abordaremos un diseño de mididas repetidas en el **espacio**, donde modelaremos la falta de independencia de los datos con una matriz de covarianzas. Es un modelo generalizado lineal ya que la VR tiene una distribución Poisson y se usan medidas repetidas. (GEE)

Recordar: GEE no es un método basado en verosimilitud (no hay AIC/BIC) No se puede usar tests de verosimilitud. Solo tests de Wald.

## Modelo Inicial GEE

$$
 \ln( E ( \frac {Riqueza}{5 ~ ml ~ Agua}))_i = \beta_0 + \beta_1 + SSS_ị \beta_2  TamañoParticulas_i + \beta_3 SST_i +  \beta_4 bbp_i  + \beta_5 Clorofila_i  + \beta_6 POC_i + \beta_7 Estable_i + \beta_8 Distancia_i 
$$

Como en GEE no existe una matriz de correación continua o de distancias, asumimos una Autroregresiva.

```{r}
library(geepack)

datos <- datos %>%
  arrange(object_id)

m0<-geeglm(formula= riqueza~Chl+SSS+source+gamma+bbp+POC+SST, family = poisson, data=datos,id=source,corstr = "ar1")

```

### Supuestos

Dispersion

```{r}
vif(m0)
testDispersion(m0, type = "PearsonChisq")
sim <- simulateResiduals(fittedMod = m0, plot = T)

summary(m0)
```

Se ve subdispersion y además el summary da cualquier cosa

# Plan B

$$
 Riqueza = \beta_0 + \beta_1 + SSS_ị \beta_2  TamañoParticulas_i + \beta_3 SST_i +  \beta_4 bbp_i  + \beta_5 Clorofila_i  + \beta_6 POC_i + \beta_7 Estable_i + \beta_8 Distancia_i + \epsilon_i
\\ \epsilon_i \sim Normal(0,\sigma^2_{frente})
\\ i : 1 -75
$$

debido que gee no incorpora las distribuciones que corrigen la **subdispersion**.

Asumimos que la variable resupesta se aproxima a una distribucion normal ya que la experanza \> 8.

Lugeo Probamos modelar la varianza ya que en Poisson \> media \> varianza, asumiimos un varPower o varExp. Mejor modelo termino siendo VarIdent con una varianza para cada source.

Sacamos el POC, particulas

#### Seleccion de modelos

#### Modelos

```{r}

m_Nulo = gls(model = riqueza ~ 1 , weights = varIdent(form = ~1|source) , data = datos,correlation = corCAR1(form = ~ dist|source))

m_Source = gls(model = riqueza ~ source ,data = datos, weights = varIdent(form = ~1|source),correlation = corCAR1(form = ~ dist|source))

m_SSS = gls(model = riqueza ~ SSS   ,data = datos, weights = varIdent(form = ~1|source),correlation = corCAR1(form = ~ dist|source))

m_SSS_S = gls(model = riqueza ~ SSS *  source  ,data = datos, weights = varIdent(form = ~1|source),correlation = corCAR1(form = ~ dist|source))

m_Clo  = gls(model = riqueza ~ Chl    ,data = datos, weights = varIdent(form = ~1|source),correlation = corCAR1(form = ~ dist|source))

m_Clo_S  = gls(model = riqueza ~ Chl * source   ,data = datos, weights = varIdent(form = ~1|source),correlation = corCAR1(form = ~ dist|source))

m_POC = gls(model = riqueza ~ POC    ,data = datos, weights = varIdent(form = ~1|source),correlation = corCAR1(form = ~ dist|source))


m_POC_S = gls(model = riqueza ~ POC * source   ,data = datos, weights = varIdent(form = ~1|source),correlation = corCAR1(form = ~ dist|source))

m_bbp = gls(model = riqueza ~ bbp    ,data = datos, weights = varIdent(form = ~1|source),correlation = corCAR1(form = ~ dist|source))

m_bbp_S = gls(model = riqueza ~ bbp * source   ,data = datos, weights = varIdent(form = ~1|source),correlation = corCAR1(form = ~ dist|source))

m_dist =gls(model = riqueza ~ dist    ,data = datos, weights = varIdent(form = ~1|source),correlation = corCAR1(form = ~ dist|source))

m_dist_S =gls(model = riqueza ~ dist  * source   ,data = datos, weights = varIdent(form = ~1|source),correlation = corCAR1(form = ~ dist|source))

m_dist_Sxbbp =gls(model = riqueza ~ dist  * source * bbp   ,data = datos, weights = varIdent(form = ~1|source),correlation = corCAR1(form = ~ dist|source))

m_distxbbp =gls(model = riqueza ~ dist   * bbp + source  ,data = datos, weights = varIdent(form = ~1|source),correlation = corCAR1(form = ~ dist|source))

m_gamma=gls(model = riqueza ~ gamma   ,data = datos, weights = varIdent(form = ~1|source),correlation = corCAR1(form = ~ dist|source))

m_gamma_S=gls(model = riqueza ~ gamma * source  ,data = datos, weights = varIdent(form = ~1|source),correlation = corCAR1(form = ~ dist|source))

m_SSS_Sxbbp =gls(model = riqueza ~ dist  * source * SSS   ,data = datos, weights = varIdent(form = ~1|source),correlation = corCAR1(form = ~ dist|source))

m_SSS_Sxbbp =gls(model = riqueza ~ bbp  * source * SSS   ,data = datos, weights = varIdent(form = ~1|source),correlation = corCAR1(form = ~ dist|source))


m_bbp_clo_S = gls(model = riqueza ~ (bbp + Chl)  * source ,data = datos, weights = varIdent(form = ~1|source),correlation = corCAR1(form = ~ dist|source))

m_todas_s = gls(model = riqueza ~ (bbp + SSS + gamma + SST + POC + Chl)  * source ,data = datos, weights = varIdent(form = ~1|source),correlation = corCAR1(form = ~ dist|source))

m_bbp_SxSSS = gls(model = riqueza ~ ( SSS * source ) + bbp ,data = datos, weights = varIdent(form = ~1|source),correlation = corCAR1(form = ~ dist|source))

m_bbp_SSSxsource = gls(model = riqueza ~ ( bbp + SSS  )  * source  ,data = datos, weights = varIdent(form = ~1|source),correlation = corCAR1(form = ~ dist|source))

m_bbpxSSSxsource = gls(model = riqueza ~ bbp * SSS* source  ,data = datos, weights = varIdent(form = ~1|source),correlation = corCAR1(form = ~ dist|source))



modelos <- list(
  "Nulo" = m_Nulo,
  "Source" = m_Source,
  "SSS" = m_SSS,
  "Clo" = m_Clo,
  "POC" = m_POC,
  "bbp" = m_bbp,
  "gamma" = m_gamma,
  "dist" = m_dist,
  "SSS_S" = m_SSS_S,
  "Clo_S" = m_Clo_S,
  "POC_S" = m_POC_S,
  "bbp_S" = m_bbp_S,
  "gamma_S" = m_gamma_S,
  "dist_S" = m_dist_S,
  "dist_Sxbbp" = m_dist_Sxbbp,
  "distxbbp" = m_distxbbp,
  "SSS_Sxbbp" = m_SSS_Sxbbp,
  "(bbp+Chl) * Source" = m_bbp_clo_S,
  "bbp + (Chl * Source)" = m_bbp_SxSSS,
  "Todas Interactuando con Source" = m_todas_s,
  "(bbp + SSS) * source"  = m_bbp_SSSxsource,
  "bbp * SSS * source" = m_bbpxSSSxsource
)

```

#### Comparación

```{r}
aic_values <- sapply(modelos, AIC)
bic_values <- sapply(modelos, BIC)
rse_values <- sapply(modelos, sigma)
phi_values <- sapply(modelos, function(m) {
  
  # Get the correlation structure
  cor_struct <- coef(m$modelStruct$corStruct, unconstrained = FALSE)
  
})

p_value_last_coef <- sapply(modelos, function(m) {
  
  # Get the coefficient table from the summary
  tTable <- summary(m)$tTable
  
  # Get the number of rows (which is the last coefficient)
  last_row <- nrow(tTable)
  
  # Get the p-value from that last row
  p_val <- tTable[last_row, "p-value"]
  
  return(p_val)
})

results_table <- data.frame(
  Phi = phi_values,
  SE = rse_values,
  AIC = aic_values,
  BIC = bic_values,
  P_valor = p_value_last_coef
)

library(knitr)

kable(results_table, 
      digits = 3, 
      caption = "GLS Model Comparison") # <-- No format argument


```

```{r}
residuals = residuals(m_SSS_S, type = "pearson")
plot( predict(m_SSS_S) , residuals)

```

#### Comparaciones Sin Source

```{r}


m_SSS2 = gls(model = riqueza ~ poly(SSS, 2)   ,data = datos, weights = varIdent(form = ~1|source),correlation = corCAR1(form = ~ dist|source))

m_SSS3 = gls(model = riqueza ~ poly(SSS, 3)   ,data = datos, weights = varIdent(form = ~1|source),correlation = corCAR1(form = ~ dist|source))

m_Chl2 = gls(model = riqueza ~ poly(Chl, 2)   ,data = datos, weights = varIdent(form = ~1|source),correlation = corCAR1(form = ~ dist|source))

m_Chl3 = gls(model = riqueza ~ poly(Chl, 3)   ,data = datos, weights = varIdent(form = ~1|source),correlation = corCAR1(form = ~ dist|source))

m_Chl3xSSS2 = gls(model = riqueza ~ poly(Chl, 3) * poly(SSS , 2)  ,data = datos, weights = varIdent(form = ~1|source),correlation = corCAR1(form = ~ dist|source))

m_ChlxSSS = gls(model = riqueza ~ Chl * SSS ,data = datos, weights = varIdent(form = ~1|source),correlation = corCAR1(form = ~ dist|source))

m_gamma2 = gls(model = riqueza ~ poly(gamma, 2)   ,data = datos, weights = varIdent(form = ~1|source),correlation = corCAR1(form = ~ dist|source))

m_gamma3 = gls(model = riqueza ~ poly(gamma, 3)   ,data = datos, weights = varIdent(form = ~1|source),correlation = corCAR1(form = ~ dist|source))

m_SSS3xgamma = gls(model = riqueza ~ poly(SSS, 2) * gamma   ,data = datos, weights = varIdent(form = ~1|source),correlation = corCAR1(form = ~ dist|source))

m_SSSxgamma = gls(model = riqueza ~ SSS * gamma   ,data = datos, weights = varIdent(form = ~1|source),correlation = corCAR1(form = ~ dist|source))


modelos_sinSource <- list(
  "Nulo" = m_Nulo,
  "SSS" = m_SSS,
  "Clo" = m_Clo,
  "gamma" = m_gamma,
  "SSS^2" = m_SSS2,
  "SSS^3" = m_SSS3,
  "Chl^2" = m_Chl2,
  "Chl^3" = m_Chl3,
  "Chl3^2 * SSS^2" = m_Chl3xSSS2,
  "Chl * SSS" = m_ChlxSSS,
  "gamma^2" = m_gamma2,
  "gamma^3" = m_gamma3,
  "SSS3 * gamma" = m_SSS3xgamma,
  "m_SSSxgamma" = m_SSSxgamma

)

aic_values <- sapply(modelos_sinSource, AIC)
bic_values <- sapply(modelos_sinSource, BIC)
rse_values <- sapply(modelos_sinSource, sigma)
phi_values <- sapply(modelos_sinSource, function(m) {
  
  # Get the correlation structure
  cor_struct <- coef(m$modelStruct$corStruct, unconstrained = FALSE)
  
})

p_value_last_coef <- sapply(modelos_sinSource, function(m) {
  
  # Get the coefficient table from the summary
  tTable <- summary(m)$tTable
  
  # Get the number of rows (which is the last coefficient)
  last_row <- nrow(tTable)
  
  # Get the p-value from that last row
  p_val <- tTable[last_row, "p-value"]
  
  return(p_val)
})

results_table <- data.frame(
  Phi = phi_values,
  SE = rse_values,
  AIC = aic_values,
  BIC = bic_values,
  P_valor = p_value_last_coef
)

library(knitr)

summary(m_SSS3xgamma)

kable(results_table, 
      digits = 3, 
      caption = "GLS Model Comparison") # <-- No format argument



```

### Supuestos

```{r}
library(performance)

model_names <- names(modelos_sinSource)
# sapply(modelos_sinSource, check_model) 

for (current_name in model_names) {
  
  m <- modelos_sinSource[[current_name]]
    
  r = residuals(m , type = "pearson")
  predichos = predict(m)
  
  
  plot(predichos , r , main = current_name)
  abline(h = 0, col = "red", lty = 2)
  print(shapiro.test(r))
}

```

```{r}
summary(m_bbp_clo_S)
summary(m_SSS_Sxbbp)
summary(m_bbp_SSSxsource)
```
